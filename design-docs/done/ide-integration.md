## Feature -  Improve IDE project naming deduplication strategy

### Motivation

If we got a project structure like this:

    :foo:app
    :bar:app
    :foobar:app

it currently results in the following eclipse project names:

    app
    bar-app
    foobar-app

This behaviour can be quite confusing in the IDE. To make things clearer the deduplication strategy
should be changed in a way that it results in:

    foo-app
    bar-app
    foobar-app


# Implementation Plan

The general algorithm will look like this:

1. if no duplicate of project name is found in the hierarchy, use the original name as IDE project name
2. root project name keeps the original name in IDE
3. for all non unique project names

    3.1 the IDE project name candidate is changed to be _deduplicated_ `project.parent.name` + `-` + `project.name`

    3.2 duplicate words in the IDE project name candidate are removed.( eg `gradle-gradle-core` becomes `gradle-core`

    3.3 skip 3.2 for identical parent and child project name

    3.4 repeat starting from 3.1 with all projects with non unique names yet

4. deprecate setting ide project name in whenMerged/beforeMerged hook.

# Test Coverage

* _gradle eclipse_ / _gradle idea_ on root of multiproject with given project layout containing duplicate names:

```
    root
    \- foo
       \- app
    \- bar
       \- app
```

results in IDE project names

```
    root
    \- foo
       \- foo-app
    \- bar
       \- bar-app
```
* _gradle eclipse_ / _gradle idea_ on root of multiproject with given project layout containing with no duplicate names:

```
    root
    \- foo
       \- bar
    \- foobar
       \- app
```

results in IDE project names

```
    root
    \- foo
       \- bar
    \- foobar
       \- app
```


* explicit configured IDE project name take precedence over deduplication:
    given

```
     root
     \- foo
        \- app
           \-build.gradle // contains e.g. eclipse.project.name = "custom-app" / ideaModule.module.name = "custom-app"
     \- bar
        \- app
```

results in

```
     root
     \- foo
        \- custom-app
     \- bar
        \- app
```


* given project layout

```
    app
    \- app
    \- util
```

results in

```
    app
    \- app-app
    \- util
```

* given project layout

```
    root
    \- app
    \- services
       \- bar
          \- app
```

results in

```
    root
    \- root-app
    \- services
       \- bar
          \- bar-app
```

* given project layout

```
    root
    |- foo-bar
    |- foo
    |  \- bar
    \- baz
       \- bar
```

results in

```
    root
    \- foo-bar
    \- foo
       \- root-foo-bar
    \- baz
       \- root-baz-bar

```


* given project layout

```
    myproject
    \- myproject-app
    \- myproject-bar
       \- myproject-app
```

results in

```
    myproject
    \- myproject-app (instead of myproject-myproject-app)
    \- myproject-bar
       \- myproject-bar-app (instead of myproject-bar-myproject-app)
```

* deduplication logics works with deduplicated parent module name. given project layout:

```
   root
    \- bar
        \- services
            \- rest
    \- foo
            \- services
                \- rest
```

results in

```
    root
    \- bar
        \- bar-serivces
            \- bar-services-rest
    \- foo
        \- foo-serivces
            \- foo-services-rest
```

* setting ide project name within `whenMerged` results in a deprecation warning.
* setting ide project name within `beforeMerged` results in a deprecation warning.
* tests work with IDE gradle plugins and with IDE model queried via tooling api

## Feature - Tooling API parity with command-line for task visualisation and execution

### GRADLE-2434 - IDE visualises and runs task selectors (DONE)

On the command-line I can run `gradle test` and this will find and execute all tasks with name `test` in the current project
and all its subprojects.

Expose some information to allow the IDE to visualise this and execute builds in a similar way.

See [tooling-api-improvements.md](tooling-api-improvements.md#story-gradle-2434---expose-the-aggregate-tasks-for-a-project)

### IDE hides implementation tasks (DONE)

On the command-line I can run `gradle tasks` and see the public tasks for the build, and `gradle tasks --all` to see all the tasks.

Expose some information to allow the IDE to visualise this.

See [tooling-api-improvements.md](tooling-api-improvements.md#expose-information-about-the-visibility-of-a-task)

### Story - Classpath export across projects in multi-project builds (DONE)

Project files generated by the Gradle Idea and Eclipse plugins are responsible for deriving the classpath from the declared list of dependencies in the build file. The current
 behavior is best explained by example. Let's assume project A and B. Both projects are part of a multi-project build. Project B declares a project dependency on project A. The generated classpath
 of project B is a union of the classpath of project A (the generated JAR file plus its dependencies) and its own declared top-level dependencies and transitive dependencies. Classpath
 ordering matters. In practice this means the following: given that project A and B depend on a specific library with different versions, the "exported" dependency versions win as they happens
 to be listed first in classpath of project B. This behavior might lead to compilation and runtime issues in the IDE as no conflict-resolution takes place across projects.

[Concrete example](https://github.com/bmuschko/eclipse-export): Project B declares a project dependency on project A. Project A  declares a dependency in Guava 15.0, Project B declares a dependency on
Guava 16.0.1. Project B depends on A. If you generate the project files with the Gradle Eclipse plugin, project A is exported to B and appears to be on the classpath as the first entry (exported project).
As a result Guava 15 is found and not 16.0.1. Any code in B that relies on Guava's API from 16.0.1 will cause a compilation error.

The other use case to consider is the generation of project files directly via the IDE's import capabilities. In this scenario the Gradle IDE plugins might be used or only partially depending on
the product.

- IntelliJ: To our knowledge depends on classes from Gradle's internal API to generate classpath (`org.gradle.plugins.ide.internal.resolver.DefaultIdeDependencyResolver`).
- Eclipse: STS uses a custom model for the tooling API to generate the classpath. On top of the project/external classpath provided by the tooling API, the solution uses so called classpath containers
which are built using [Eclipse APIs](https://github.com/spring-projects/eclipse-integration-gradle/blob/f40acf8033db935270225e6ff4b5989f2f45abb4/org.springsource.ide.eclipse.gradle.core/src/org/springsource/ide/eclipse/gradle/core/classpathcontainer/GradleDependencyComputer.java#L116).
A classpath container is reflect in a single classpath entry in the generated `.classpath` file. The Gradle IDE plugins can be invoked optionally to derive additional customizations for the project files.
- Buildship: See Eclipse. Is there any difference in behavior? How is the classpath generated right now?

#### Implementation

Expose the `exported` flag for `EclipseProjectDependency` and `ExternalDependency`.

- Buildship should honor this flag when available, as later Gradle versions may use a different mapping and Buildship should not make assumptions regarding how the mapping works.

Change the Eclipse classpath mapping to contain transitive closure of all dependencies:

- All projects
- All external libraries
- All dependencies with `exported` set to `false`
- Deprecate `EclipseClasspath.noExportConfigurations`. This would no longer be used.
- Deprecate `AbstractLibrary.declaredConfigurationName`. This would no longer be used.
- Currently `DefaultIdeDependencyResolver.getIdeProjectDependencies()` returns direct project dependencies, should locate all project dependencies in the graph (see `ResolutionResult.getAllComponents()`).
- Currently `DefaultIdeDependencyResolver.getIdeRepoFileDependencies()` ignores anything reachable via a project dependency, should all external dependencies in the graph (as above).
- Currently `DefaultIdeDependencyResolver.getIdeLocalFileDependencies()` returns direct dependencies, should locate all self-resolving dependencies in the graph.
    - Implementation should simply iterate over the files of the configuration and remove anything that is associated with an artifact.
- Should end up with much simpler implementations for the methods of `DefaultIdeDependencyResolver`.

Change the IDEA classpath mapping to do something similar.

- Should be applied on a per-scope basis.
- Must continue to remove duplicates inherited from other scopes.
- IDEA mapping shares `DefaultIdeDependencyResolver` with the Eclipse mapping, so IDEA mapping should just work.

#### Test cases

- Verify the `exported` flag is available for Tooling API `EclipseProject` model's project and external dependencies.
- The classpath generated by the Gradle IDE plugins need to contain all dependencies of a project, including transitive dependencies:
    - Project A depends on project B depends on project C => IDE model for project A should include dependencies on both project B and project C.
    - Project A depends on project B depends on external library 'someLib' => IDE model for project A should include dependencies on both project B and 'someLib.
    - Project A depends on project B depends on file dependency => IDE model for project A should include dependencies on both project B and the file dependency.
    - No dependencies should be exported.
- In a multi-project build have two projects with conflicting version on an external dependency.
    - Project A depends on Guava 15.
    - Project B depends on Guava 16.0.1. A class in this project depends on API of version 16.0.1.
    - The generated project files for project B use Guava version 16.0.1 to allow for proper compilation.
    - This behavior should be observed using the IDE plugins as well as the tooling API.
    - *Manually* test that this scenario works with both Eclipse and IDEA, using the generated IDE project files.
- Existing test cases for the Idea and Eclipse plugins and Tooling API need to be modified to reflect changed export behavior.

#### Open issues

- Should we consider the use a classpath container solution? Given that some users check in the project files into VCS (for good or bad - it does exist in reality), every regenerated project file
 would need to be checked back into version control. With frequent changes that could get cumbersome. The benefit of using a classpath container is that the `.classpath` file doesn't change over
 time. The downside of using a classpath container is that it requires the use of Eclipse APIs and additional dependencies to Gradle core. As a side note: This model is used for other Eclipse IDE
  integrations like M2Eclipse and IvyDE so it's not uncommon. My guess is that it would require almost a rewrite of the existing code in the Gradle Eclipse plugin.

